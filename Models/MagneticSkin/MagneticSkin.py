# -*- coding: utf-8 -*-
"""Config for the SensorFinger"""

__authors__ = "sescaidanavarro, tnavez"
__contact__ = "stefan.escaida@uoh.cl, tanguy.navez@inria.fr"
__version__ = "1.0.0"
__copyright__ = "(c) 2020, Inria"
__date__ = "Oct 28 2022"

import math
import numpy as np
import Sofa
# import SofaRuntime
# from stlib3.scene import Scene
import time
from scipy.spatial.transform import Rotation as R 
import rigidification
from BaseFitnessEvaluationController import BaseFitnessEvaluationController

from Generation import MagneticSkin


def calculate_B_field(distance_r_mm, magnetic_moment_direction, mu_magnitude):
    """
    Calculates the magnetic field B generated by a magnetic dipole at a given point.

    """

    # Convert the distance vector to an array and compute its norm
    r = np.array(distance_r_mm) * 1e-3  #  mm a m

    r_magnitude = np.linalg.norm(r)           

    # Unit vector in the direction of r
    r_hat = r / r_magnitude
    Mu_hat = magnetic_moment_direction
    # Full magnetic moment vector (direction * magnitude)
    mu = [x * mu_magnitude for x in Mu_hat]

    # Compute the dipole field tensor: 3*r̂*r̂ᵀ - I
    tensor = 3 * np.outer(r_hat, r_hat) - np.identity(3)

    # Apply the formula: B = (μ₀ / 4π) * (tensor ⋅ μ) / |r|³
    numerator = np.matmul(tensor, mu)
    denominator = 4 * np.pi * (abs(r_magnitude)**3)

    # Magnetic field B in Tesla
    B_field = numerator / denominator

    # Convert Tesla to microTesla 
    B_field_pT = B_field * 1e6 #1000000000000000


    return B_field_pT


#llamar a la funcion en onanimateevent con self.config.Height 
def Normal_Trajectory(point, delta, height):  
    point1 = np.array([point[0], point[1], height + delta])
    point2 = np.array([point[0], point[1], height])
    return point1, point2


def S_trajectory(points, height):
    """
    Generates an S-shaped trajectory
    """

    pts = np.array(points)
    x_vals = np.unique(pts[:, 0])

    trayectoria = []
    invertir = False

    for x in x_vals:
        columna = pts[pts[:, 0] == x]
        columna = columna[np.argsort(columna[:, 1])]
        if invertir:
            columna = columna[::-1]

        for p in columna:
            x_, y_ = p
            trayectoria.append([x_, y_, height])  

        invertir = not invertir

    return np.array(trayectoria)



class FitnessEvaluationController(BaseFitnessEvaluationController):   
    
    def __init__(self, *args, **kwargs):

        print('>>> Start Init SOFA scene ...')

        super(FitnessEvaluationController,self).__init__(*args, **kwargs)

        self.ModelNode = self.rootNode.Simulation.Articulation.ServoWheel.RigidNode.RigidifiedNode.deformableNode.model     
        # self.RigidMO = kwargs['RigidMO']   
        # self.CableConstraint = self.ModelNode.cables.cable1.CableConstraint
        # self.ReferenceMO = self.rootNode.ReferenceMONode.ReferenceMO
        # self.StartPosition = np.array(self.ReferenceMO.position.value[0])
        # self.StartAngle = math.acos( np.abs(self.StartPosition[2]) / np.linalg.norm(self.StartPosition)) 
        # self.FollowingMO = self.rootNode.model.FollowingMONode.FollowingMO
        
        
        
        # ----- SOFA nodes and objects -----
        # self.RootNode = kwargs['RootNode']
        self.RigidMO = kwargs['RigidMO']
        self.SensorMO = kwargs['SensorMO']
        self.CFF = kwargs['CFF']
        self.CFFSphereROI = kwargs['CFFSphereROI'] 
        self.CFFMO = kwargs['CFFMO']   
        # self.articulationAngle = kwargs['articulationAngle']

        # Objective evaluation variables
        self.current_iter = 0
        current_objectives = self.config.get_currently_assessed_objectives()
        self.max_iter = max([self.config.get_objective_data()[current_objectives[i]][1] for i in range(len(current_objectives))])



        #Data
        self.data_Force = []
        self.data_MagnetPose = []
        self.data_SensorPose = []
        self.data_MagneticField = []
        self.data_IdenterPosition = []


        # ----- Time and PID variables -----
        self.t = 0
        self.dt = 0.01
        self.time = 0
        self.Kp, self.Ki, self.Kd = 100, 1e7, 1e2
        self.integral_vec = np.zeros(3)
        self.prev_error_vec = np.zeros(3)

        self.closest_point = None
        self.closest_index = None
        self.fixed_index = None       # índice del punto más cercano fijado
        self.last_point_index = None  # índice de trayectoria anterior, para detectar cambios
        self.point_index = 0

        self.puntosS = S_trajectory(np.array(self.config.MagnetCenters)[:, :2], height=self.config.Height)
        # print(self.puntosS)
        self.puntotrayectoria = 0
        self.wait_frames = 0
        self.frames_to_wait = 2  # número de frames a esperar antes de fijar el índice

    def pid_vector(self, variable, setpoint, dt):

        if not hasattr(self, 'integral_vec'):
            self.integral_vec = np.zeros(3)
            self.prev_error_vec = np.zeros(3)

        error = setpoint - variable
        P_out = self.Kp * error
        self.integral_vec += error * dt
        I_out = self.Ki * self.integral_vec
        derivative = (error - self.prev_error_vec) / dt
        D_out = self.Kd * derivative

        output = P_out + I_out + D_out
        self.prev_error_vec = error

        return output   # np.array([ux, uy, uz])
    

    def MoveCFFSphereROI(self, pos):   
        self.CFFSphereROI.centers = [pos.tolist()]

            
    def selectCenterPoint(self, positionSphere, roi_indices, positions):
        roi_positions = positions[roi_indices]
        distances = np.linalg.norm(roi_positions - positionSphere, axis=1)
        min_index = np.argmin(distances)
        closest_point = roi_positions[min_index]
        closest_index = int(roi_indices[min_index])  
        return closest_point, closest_index



        
        
        print('>>> ... End')



    def onAnimateBeginEvent(self, dt):
        # t0 = time.time
        # print(self.puntosS)
        self.current_iter += 1
        self.t += 1
        
        print('hola', self.t)
        # t1 = time.time()
        # print(f"Tiempo update físico: {t1 - t0:.6f} s")
        roi_indices = self.CFFSphereROI.indices.value
        n_roi_indices = len(roi_indices)
        # print(n_roi_indices)
        positions = self.CFFMO.position

        trajectory_points = Normal_Trajectory(point = self.puntosS[self.point_index], 
                                                     delta = -0.5, height=self.config.Height)
        # print(trajectory_points)


        current_Setpoint = trajectory_points[self.puntotrayectoria]


        self.MoveCFFSphereROI(self.puntosS[self.point_index])
        CurrentPositionSphere = np.array(self.CFFSphereROI.centers.value[0])

        print('CurrentPositionSphere',CurrentPositionSphere)


        #fijar un indice para ver su posicion cuando el point_index cambie 
        if self.point_index is not None and self.last_point_index != self.point_index:
            if self.wait_frames < self.frames_to_wait:
                self.wait_frames += 1
                print(f"frame {self.wait_frames}/{self.frames_to_wait}")
                return 
            else:
                self.closest_point, self.closest_index = self.selectCenterPoint(
                    positionSphere=CurrentPositionSphere,
                    roi_indices=roi_indices,
                    positions=positions
                )
                self.fixed_index = self.closest_index
                self.last_point_index = self.point_index
                self.wait_frames = 0  

        variable = positions[self.fixed_index]  
        print('variable', variable)
        error =  current_Setpoint - variable
        error_norm = np.linalg.norm(error)

 

        # PID 
        forcesXYZ = self.pid_vector(variable, current_Setpoint, self.dt)
        self.CFF.totalForce.value = forcesXYZ

        
        force_indice = forcesXYZ/n_roi_indices
        


        tol = 0.005
        if tol > error_norm:
            self.puntotrayectoria += 1
            if self.puntotrayectoria == len(trajectory_points) :
                self.point_index += 1 
                self.puntotrayectoria = 0


        MagnetPose = self.RigidMO.position.value[1:, :]       
        SensorPose = self.SensorMO.position.value

        # print('MagnetPose', MagnetPose)
        # print('SensorPose', SensorPose)

 # ---- Extract 3D positions of magnets and sensors ----
        MagnetPosition = MagnetPose[:, :3]
        # print('Lista imanes:', MagnetPosition)

        SensorPosition = SensorPose[:, :3]


        GlobalMagneticField = []

        for j in range(len(SensorPosition)):
        
            LocalMagneticField = []
            quat_sensor = self.SensorMO.position.value[j, 3:7]


            MiR_Sensor = R.from_quat(quat_sensor)
            R_sensor_inv = R.from_quat(quat_sensor).inv()
            rotation_matrix_sensor_inv = R_sensor_inv.as_matrix()

            for i in range(len(MagnetPosition)):
                Dist_Sensor_global = SensorPosition[j] - MagnetPosition[i]
                delta_local = rotation_matrix_sensor_inv @ Dist_Sensor_global
                quat_Magnet = self.RigidMO.position.value[i+1, 3:7]
                MiR_Magnet = R.from_quat(quat_Magnet)  # (x, y, z, w)
                rotation_Matrix_Magnet = MiR_Magnet.as_matrix() 
                rotation_Matrix = MiR_Sensor.inv().as_matrix() @ rotation_Matrix_Magnet
                Direccion_momento_magnetico = rotation_Matrix[:, 2]
                

                LocalMagneticField.append(calculate_B_field(delta_local, Direccion_momento_magnetico, self.config.mu_magnitude))
            TotalMagneticField = np.sum(LocalMagneticField, axis=0)
           
           
           #data 
            GlobalMagneticField.append(TotalMagneticField)

            # print(f'global magnetic {j}', TotalMagneticField )


        # if self.current_iter == self.max_iter:            
            
        #     current_objectives_names = self.config.get_currently_assessed_objectives()

        #     for i in range(len(current_objectives_names)):

        #         current_objective_name =  current_objectives_names[i]

                # # Sensibility metrics. Reflects the efficiency of a pressure sensor.
                # if "PressureSensibility" == current_objective_name:
                #     CavityVolume = self.ModelNode.Cavity01.SurfacePressureConstraint.cavityVolume.value
                #     Cavity01VolumeGrowth = self.SurfacePressureConstraint1.volumeGrowth.value
                #     Growth = np.abs(Cavity01VolumeGrowth/CavityVolume)
                #     print("Growth differential: ", Growth)
                #     self.objectives.append(Growth)
                    
                # # Sensibility metrics to volume variation. Reflects the efficiency of a volume sensor.
                # if "VolumeSensibility" == current_objective_name:
                #     Cavity01VolumeGrowth = self.SurfacePressureConstraint1.volumeGrowth.value
                #     Growth = np.abs(Cavity01VolumeGrowth)
                #     print("Growth differential: ", Growth)
                #     self.objectives.append(Growth)
                    
                

def createScene(rootNode, config):

              
    # SofaRuntime.importPlugin("ArticulatedSystemPlugin") 
    # rootNode.addObject('RequiredPlugin', name='Sofa.Component.ODESolver.Backward')
    # rootNode.addObject('RequiredPlugin', name='Sofa.Component.AnimationLoop')
    

    pluginsList = [
        'Sofa.Component.Visual',
        'ArticulatedSystemPlugin',
        'SoftRobots',
        "SofaPython3",
        "Sofa.Component.LinearSolver.Iterative",
        "Sofa.Component.ODESolver.Backward",
        'SoftRobots.Inverse',
        'Sofa.Component.AnimationLoop',
        'Sofa.Component.Constraint.Lagrangian.Correction',
        'Sofa.Component.Constraint.Lagrangian.Solver',
        'Sofa.Component.Setting',
        'Sofa.Component.Constraint.Projective',
        'Sofa.Component.IO.Mesh',
        'Sofa.Component.Topology.Container.Dynamic',
        'Sofa.Component.LinearSolver.Direct',
        'Sofa.GL.Component.Shader',
        'Sofa.Component.Mapping.NonLinear',
        'Sofa.Component.Mass',
        'Sofa.Component.SolidMechanics.FEM.Elastic',
        'Sofa.Component.Engine.Select', 
        'Sofa.Component.SolidMechanics.Spring',
        'Sofa.Component.Mapping.Linear', 
        'Sofa.Component.StateContainer',
        'Sofa.Component.Topology.Container.Constant',
        'Sofa.Component.Visual',
        'Sofa.GL.Component.Rendering3D',
        'Sofa.GUI.Component',
        'Sofa.Component.MechanicalLoad'

    ]
    # scene = Scene(rootNode, plugins=pluginsList, iterative=False)
    # scene.addMainHeader()


    for name in pluginsList:
        rootNode.addObject("RequiredPlugin", name=name)

    rootNode.addObject('VisualStyle', displayFlags='hideWireframe showBehaviorModels hideCollisionModels hideBoundingCollisionModels showForceFields showInteractionForceFields')
    rootNode.findData('gravity').value = [0, 0, -9810]
    rootNode.findData('dt').value = 0.02

    rootNode.addObject('FreeMotionAnimationLoop')
    rootNode.addObject('GenericConstraintSolver', tolerance="1e-12", maxIterations="10000")
    # rootNode.addObject('GenericConstraintSolver', maxIterations=1e3, tolerance=1e-5)

    # rootNode.addObject('BackgroundSetting', color='0.1 0.85 0.85')
    # root = Sofa.Core.Node()



    #He tenido que cambiar
    # rootNode.addObject('RequiredPlugin', name='Sofa.GL.Component.Shader')
    # rootNode.addObject('RequiredPlugin', name='Sofa.Component.Mapping.NonLinear')
    # rootNode.addObject('RequiredPlugin', name='Sofa.Component.Constraint.Projective')




    rootNode.addObject('DefaultVisualManagerLoop')



    ##################
    ### Load model ###
    ##################



    #----------------------
    # Rigidification - start
    #----------------------          
              

    completeMesh = rootNode.addChild('completeMesh')
    # completeMesh.addObject('MeshVTKLoader', name='loader', filename=VolumetricMeshPath)

    completeMesh.addObject('MeshVTKLoader', name='loader', 
                    filename = config.get_mesh_filename(mode = "Volume", refine = 0, 
                                                        generating_function = MagneticSkin, 
                                                        length = config.Length, 
                                                        width = config.Width,
                                                        height = config.Height,                                                    
                                                        magnet_boxes=config.MagnetBoxCoords,
                                                        # lc_surface = config.SurfaceMeshCharacteristicLength,
                                                        lc= config.VolumeMeshCharacteristicLength))

    completeMesh.addObject('TetrahedronSetTopologyContainer', src='@loader', name='container')
    completeMesh.init()


    Boxes = []
    for i in range(len(config.rigidObjectsBoxCoords)):
        boxTip = completeMesh.addObject('BoxROI', name='Tip'+str(i), box=[config.rigidObjectsBoxCoords[i]], drawBoxes=True, 
                                        tetrahedra="@container.tetrahedra" , position="@container.position")
        Boxes.append(boxTip)
        boxTip.init()

    

    MeshTetra = completeMesh.addObject('MeshTopology', name="AllMesh", src='@loader')
    positionAllPoints = MeshTetra.findData('position').value;
    nbPoints = len(positionAllPoints)

    IndicesWithRigidIdx = np.empty((0,2), dtype=int)
    
    for (i,Box) in enumerate(Boxes):
        IndicesNP = np.array(Box.indices.value, dtype=int)
        NPoints = len(IndicesNP)
        RigidIdx = np.ones(NPoints,dtype=int)*i
        CurrentIndicesWithRigidIdx = np.append(IndicesNP.reshape((NPoints,1)), RigidIdx.reshape((NPoints,1)),1)
        IndicesWithRigidIdx = np.append(IndicesWithRigidIdx, CurrentIndicesWithRigidIdx,0)
    
    IndicesWithRigidIdxSorted = np.sort(IndicesWithRigidIdx[:,0],0)
    SortedIdxs = np.argsort(IndicesWithRigidIdx[:,0],0)
    SortedRigidIdxs = IndicesWithRigidIdx[:,1][SortedIdxs]

    indicesTip = IndicesWithRigidIdxSorted.tolist()   
    rigidBlocks = [IndicesWithRigidIdxSorted.tolist()] 
    
    DeformableIndicesTotal = []    
    
    for i in range(nbPoints):
        if i not in indicesTip:
            DeformableIndicesTotal.append(i)                                 

    freeBlocks = np.sort(DeformableIndicesTotal)    
    IdxsOrderedFreeBlocks = np.argsort(DeformableIndicesTotal)    
    indexPairs = np.array(rigidification.fillIndexPairs(nbPoints,freeBlocks,rigidBlocks))
    NPPointsDeformable = positionAllPoints[DeformableIndicesTotal,:]   
    NPSortedPointsDeformable = NPPointsDeformable[IdxsOrderedFreeBlocks, :]
    PointsDeformable = NPSortedPointsDeformable.flatten().tolist()
    pointsBody = PointsDeformable
    #deformablePoints = pointsBody
       
    pointsTip = np.array(positionAllPoints[indicesTip,:]).flatten().tolist()                                                 
    rigidIndexPerPoint = SortedRigidIdxs.tolist()



    # ----------------------------------------
    #            Articulation                           
    # ----------------------------------------

    simulation = rootNode.addChild('Simulation')
    simulation.addObject('EulerImplicitSolver', name='TimeIntegrationSchema')
    # simulation.addObject('EulerImplicitSolver', name='TimeIntegrationSchema')
    # simulation.addObject('CGLinearSolver', name='LinearSolver', iterations=25, tolerance=1e-5, threshold=1e-5)

    simulation.addObject('SparseLDLSolver', name='LinearSolver', template='CompressedRowSparseMatrixd')
    simulation.addObject('GenericConstraintCorrection')



    servoBody = simulation.addChild('ServoBody')
    servoBody.addObject('MechanicalObject', name='dofs', template='Rigid3',
                        position=[[0., 0., config.Height/2, 0., 0., 0., 1.]]) 
    servoBody.addObject('FixedProjectiveConstraint', indices=0)
    # servoBody.addObject('JointConstraint', indices=0)


    # servoBody.addObject('FixedProjectiveConstraint', indices=0)
    servoBody.addObject('UniformMass', totalMass=0.01)

    articulationAngle = simulation.addChild('Articulation')
    articulationAngle.addObject('MechanicalObject', name='dofs', template='Vec1', position=[[0]],
                                rest_position=[[config.ArticulationAngleRad]])
    articulationAngle.addObject('RestShapeSpringsForceField', points=0, stiffness=1e12)
    articulationAngle.addObject('UniformMass', totalMass=0.01)

     # ---- ServoWheel ----
    servoWheel = articulationAngle.addChild('ServoWheel')
    servoWheel.addObject('MechanicalObject', name='dofs', template='Rigid3',
                         position=[[0., 0., config.Height/2., 0., 0., 0., 1.], 
                                   [0., 0., config.Height/2., 0., 0., 0., 1.]],
                         showObject = True, showObjectScale=4)
    

    
    # ---- Mapping articulation control to servo and body -----
    servoWheel.addObject('ArticulatedSystemMapping', input1='@../dofs', input2='@../../ServoBody/dofs', output='@./')

   
    RigidNode = servoWheel.addChild('RigidNode')
     
    
    nominal_pose = [] 
    TipOrientation = [0, 0, 0, 1]       
    
    
    for center in config.rigidObjects:
        CurrentPose = center + TipOrientation
        nominal_pose += CurrentPose
        # nominal_pose.append(CurrentPose)
        
    RigidMO = RigidNode.addObject("MechanicalObject",template="Rigid3d",name="RigidMesh", position=nominal_pose, 
                                  showObject=True, showObjectScale=1.5, showIndices=True, showIndicesScale=0.02) # orientation is 240 deg away from scene origin



    nominalPoseFreeCenters = [] 
    for center in config.rigidObjects[1:]:
        CurrentPose = center + TipOrientation
        nominalPoseFreeCenters += CurrentPose

    
    freeCenter = simulation.addChild("freeCenter")
    freeCenter.addObject("MechanicalObject", name="dofs", template="Rigid3",
                          position=nominalPoseFreeCenters,
                          showObject=False, showObjectScale=0)
    
    freeCenter.addObject("UniformMass", totalMass=0.01)
    freeCenter.addObject("EulerImplicitSolver")
    freeCenter.addObject("SparseLDLSolver")
    freeCenter.addChild(RigidNode)


    #Add the sensors 
    nominalPoseSensors = [] 
    TipOrientation = [0, 0, 0, 1]
    for center in config.SensorCenters:
        CurrentPose = center + TipOrientation
        nominalPoseSensors  += CurrentPose
    
    sensorCenter = servoWheel.addChild("sensorCenter")
    SensorMO = sensorCenter.addObject("MechanicalObject", name="dofs", template="Rigid3",
                         position=nominalPoseSensors,
                         showObject=True, showObjectScale=1.5, showIndices=True, showIndicesScale=0.02)
    sensorCenter.addObject("UniformMass", totalMass=0.01)
    sensorCenter.addObject("EulerImplicitSolver")
    sensorCenter.addObject("SparseLDLSolver")
    sensorCenter.addObject("RigidMapping", input="@Simulation/Articulation/ServoWheel/dofs", rigidIndexPerPoint=config.indexPerPointSensor)



    RigidifiedNode =  RigidNode.addChild('RigidifiedNode')   
    RigidifiedNode.addObject('MechanicalObject', name='RigidifiedMesh', position=pointsTip,
                             template='Vec3d', showObject=True, showObjectScale=4, showColor=1)       
    RigidifiedNode.addObject("RigidMapping", globalToLocalCoords="true", rigidIndexPerPoint=rigidIndexPerPoint)
    
    # pairsSub = [0, 1, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5]
    
    
    # ---- SubsetMultiMapping to connect ServoWheel and freeCenter to rigid tips ----
    RigidNode.addObject('SubsetMultiMapping',
                          name="mapping",
                          input=['@../dofs', '@/Simulation/freeCenter/dofs'],
                          output='@./', indexPairs= [config.IndexPairs])
    
    
    
    # --- Define Articulation center ----
    articulationCenter = articulationAngle.addChild('ArticulationCenter')
    articulationCenter.addObject('ArticulationCenter', parentIndex=0, childIndex=1, posOnParent=[0., 0., 0.], posOnChild=[0., 0., 0.])
    articulation = articulationCenter.addChild('Articulations')
    articulation.addObject('Articulation', translation=False, rotation=True, rotationAxis=[0, 1, 0], articulationIndex=0)
    articulationAngle.addObject('ArticulatedHierarchyContainer')
    
    
    
    # # ---- Deformable Node -----
    deformableNode = RigidifiedNode.addChild("deformableNode")
    deformableNode.addObject('PointSetTopologyContainer', position=pointsBody)
    deformableNode.addObject('MechanicalObject', name='DeformableMech', showObject = False, showObjectScale = 4)
   


    model = deformableNode.addChild('model')
    model.addObject('EulerImplicitSolver', name='nodesolver', firstOrder=0, rayleighMass=0.1, rayleighStiffness=0.1)
    model.addObject('SparseLDLSolver', name='precond', template='CompressedRowSparseMatrixd')

    # model.addObject('GenericConstraintCorrection')



    #Simulation solvers
    # model.addObject('EulerImplicitSolver', name='nodesolver') 
    # model.addObject('ShewchukPCGLinearSolver', iterations='15', name='linearsolver', tolerance='1e-5', update_step='1')
    # model.addObject('GenericConstraintCorrection')


    model.addObject('MeshVTKLoader', name='loader', 
                    filename = config.get_mesh_filename(mode = "Volume", refine = 0, 
                                                        generating_function = MagneticSkin, 
                                                        length = config.Length, 
                                                        width = config.Width,
                                                        height = config.Height,                                                    
                                                        magnet_boxes=config.MagnetBoxCoords,
                                                        # MagnetCenters = config.MagnetCenters,
                                                        # lc_surface = config.SurfaceMeshCharacteristicLength,
                                                        lc= config.VolumeMeshCharacteristicLength))
                            
    model.addObject('TetrahedronSetTopologyContainer', name='container', src='@loader')
    # model.addObject('TetrahedronSetGeometryAlgorithms')
    model.addObject('MechanicalObject', name='tetras', template='Vec3d', showIndices='false', showIndicesScale='4e-5')
    model.addObject('UniformMass', totalMass='0.1')
    model.addObject('TetrahedronFEMForceField', template='Vec3d', name='FEM', method='large', poissonRatio=config.PoissonRatio,  youngModulus=config.YoungsModulus)



    model.addObject('BoxROI', name='BaseROI', box=config.BoxROIFixCoords, drawBoxes=True, position="@tetras.rest_position", tetrahedra="@container.tetrahedra")  
    model.addObject('RestShapeSpringsForceField', points='@BaseROI.indices', stiffness='1e12')  
    model.addObject("SubsetMultiMapping",name="subsetMapping",template="Vec3d,Vec3d", input='@'+deformableNode.getPathName()+'/DeformableMech' + ' ' + '@'+RigidifiedNode.getPathName()+'/RigidifiedMesh' , output='@./tetras', indexPairs=indexPairs.tolist())
     
    # model = deformableNode.addChild('model')
    # model.addChild(rootNode)


    #Visualization                          
    modelVisu = model.addChild('visu')
    modelVisu.addObject('MeshSTLLoader', name="loader", 
                        filename = config.get_mesh_filename(mode = "Surface", refine = 0, 
                                                        generating_function = MagneticSkin, 
                                                        length = config.Length, 
                                                        width = config.Width,
                                                        height = config.Height,
                                                        magnet_boxes= config.MagnetBoxCoords,
                                                        lc= config.SurfaceMeshCharacteristicLength))
    
    modelVisu.addObject('OglModel', src="@loader", scale3d=[1, 1, 1])
    modelVisu.addObject('BarycentricMapping')


    # 	#---- Sphere ROI ---- 
    CFFNode = model.addChild('CFFNode')
    # CFFNode.addObject('MeshSTLLoader', filename=SurfaceMeshPath, name="loader")
        
    CFFNode.addObject('MeshSTLLoader', name="loader", 
                        filename = config.get_mesh_filename(mode = "Surface", refine = 0, 
                                                        generating_function = MagneticSkin, 
                                                        length = config.Length, 
                                                        width = config.Width,
                                                        height = config.Height,
                                                        magnet_boxes=config.MagnetBoxCoords,
                                                        # lc_surface = config.SurfaceMeshCharacteristicLength,
                                                        lc= config.SurfaceMeshCharacteristicLength))



    CFFMO = CFFNode.addObject('MechanicalObject', position='@loader.position') 
    # trayectoria_points = S_trajectory(np.array(config.MagnetCenters)[:, :2])
    CFFSphereROI = CFFNode.addObject('SphereROI', template="Vec3d", name='CFFSphereROI', centers=[0, 0, 0], radii=[config.indenterRadius], drawSphere=True)
    CFFSphereROI.init() 

    CFF = CFFNode.addObject('ConstantForceField', name='CFF', template='Vec3', indices='@CFFSphereROI.indices', totalForce=[0, 0, -0], showArrowSize = 0.0001)                               
    CFFNode.addObject("BarycentricMapping")
    



    ##################
    ### Controller ###                            
    ##################
    rootNode.addObject(FitnessEvaluationController(name="FitnessEvaluationController", rootNode=rootNode, 
                                                                                        config=config, 
                                                                                        RigidMO = RigidMO, 
                                                                                        SensorMO = SensorMO, 
                                                                                        CFF = CFF,
                                                                                        CFFMO = CFFMO,
                                                                                        CFFSphereROI = CFFSphereROI
                                                                                        )) 
    
    return rootNode